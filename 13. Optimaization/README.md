## React 퍼포먼스 최적화

React 는 상태가 변경되면 해당 컴포넌트 및 하위 컴포넌트에 대한 리랜더링이 수행된다. 리랜더링이 수행될 때, 기존 컴포넌트에서 변경된 사항에 대하여 비교가 이루어 지기 때문에 트리구조에서 상위 컴포넌트가 리랜더링 작업을 수행할 때 하위의 컴포넌트들도 무조건 수행되기 떄문에 대량의 컴포넌트를 품고 있는 부모 컨테이너라면 메모리 사용량이 늘어난다. 따라서 변하지 않는 컴포넌트들에 대한 랜더링도 일어나기 때문에 이를 방지하기 위한 리액트 제공 함수가 존재한다.

1. memo()

```
function App(props) {}

export default React.memo(App);
```
    - 컴포넌트의 props 가 변경되지 않으면, React.memo() 로 감싸준 컴포넌트는 리랜더링이 되지 않는다.
    - props 를 사용하지 않거나, props 가 자주 변경되지 않을 컴포넌트에 사용하기 최적

2. useCallback()

```
function App() {
    const handleClick = useCallback(() => {}, []);
}
```
    - 함수에 대한 Memozation 으로 원시값이 아닌 객체(함수) 의 변경이 없을 때 또는 의존성의 값이 변경되어 함수의 결과가 변경될 떄 사용된다.
    - React 는 컴포넌트가 랜더링 될 때 선언한 함수를 그 당시의 상태로 스냅샷을 저장하는데 상태제어를 통해 의존하는 상태값이 있고, 해당 상태가 변경 되었을 때만 새로운 함수의 스냅샷으로 교체 하는데 주로 사용된다.
    - useEffect 와 비슷한 구문으로 사용된다.
    - 변경되지 않는 이벤트나 단순 상태값을 변경하는 함수에 사용하기 최적


3. useMemo()
```
function App(props) {
    const sortList = useMemo(() => {
        return props.sort((a,b) => a-b);
    }, [props.item])
}
```
    - 값의 결과에 대한 Memozation 으로 의존성에 있는 값에 대한 변경이 이루어지면 재수행을 하고 그렇지 않으면 재수행을 하지 않는다.
    - 컴포넌트가 랜더링 될 때 해당 값에 대한 로직을 수행하고 수행된 결과에 대한 스냅샷을 저장하고 리랜더링 될 때 해당 값이 변경여부를 검사하여 변경사항이 없으면 저장된 스냅샷을 재사용 하게 된다.
    - useEffect 와 비슷한 구문으로 사용된다.
    - 변경되지 않는 값이나 자주 변경되지 않는 값에 대한 수식 또는 로직 수행하는 함수에 사용하기 최적



